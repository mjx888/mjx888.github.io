<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB 2021b"><title>Im2mesh Function List and Parameters</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.8px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: 400; text-align: left;  }
.S1 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S2 { margin-bottom: 20px; padding-bottom: 4px;  }
.S3 { margin: 0px; padding: 10px 0px 10px 5px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 700; text-align: start;  }
.S4 { margin: -1px 0px 0px; padding: 10px 0px 10px 7px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: start;  }
.S5 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S6 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S7 { margin: 10px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 15px; font-weight: 700; text-align: left;  }
.CodeBlock { background-color: #F7F7F7; margin: 10px 0 10px 0;}
.S8 { border-left: 0.992727px solid rgb(233, 233, 233); border-right: 0.992727px solid rgb(233, 233, 233); border-top: 0.992727px solid rgb(233, 233, 233); border-bottom: 0px none rgb(0, 0, 0); border-radius: 4px 4px 0px 0px; padding: 6px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S9 { border-left: 0.992727px solid rgb(233, 233, 233); border-right: 0.992727px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0.992727px solid rgb(233, 233, 233); border-radius: 0px 0px 4px 4px; padding: 0px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S10 { margin: 10px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S11 { border-left: 0.992727px solid rgb(233, 233, 233); border-right: 0.992727px solid rgb(233, 233, 233); border-top: 0.992727px solid rgb(233, 233, 233); border-bottom: 0.992727px solid rgb(233, 233, 233); border-radius: 4px; padding: 6px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S12 { border-left: 0.992727px solid rgb(233, 233, 233); border-right: 0.992727px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }</style></head><body><div class = rtcContent><h1  class = 'S0' id = 'T_86893C68' ><span>Im2mesh Function List and Parameters</span></h1><div  class = 'S1'><span></span></div><div  class = 'S2'><div  class = 'S3'><span style=' font-weight: bold;'>Table of Contents</span></div><div  class = 'S4'><a href = "#H_B8071DE5"><span>Functions
</span></a><span>    </span><a href = "#H_D96BEA78"><span>im2mesh
</span></a><span>    </span><a href = "#H_3543A41B"><span>im2meshBuiltIn
</span></a><span>    </span><a href = "#H_E00C71E9"><span>plotMeshes
</span></a><span>    </span><a href = "#H_97F00184"><span>tricost
</span></a><span>    </span><a href = "#H_43CC0292"><span>im2Bounds
</span></a><span>    </span><a href = "#H_22838695"><span>getExactBounds
</span></a><span>    </span><a href = "#H_38D85220"><span>totalNumVertex
</span></a><span>    </span><a href = "#H_8514C0F0"><span>getCtrlPnts
</span></a><span>    </span><a href = "#H_30E7C1B8"><span>plotBounds
</span></a><span>    </span><a href = "#H_FCA5055E"><span>totalNumCtrlPnt
</span></a><span>    </span><a href = "#H_10050E27"><span>smoothBounds
</span></a><span>    </span><a href = "#H_4587B208"><span>smoothBoundsCCMA
</span></a><span>    </span><a href = "#H_91DFF793"><span>simplifyBounds
</span></a><span>    </span><a href = "#H_2CF1EA9E"><span>delZeroAreaPoly
</span></a><span>    </span><a href = "#H_3BBB7560"><span>getPolyNodeEdge
</span></a><span>    </span><a href = "#H_FCED5924"><span>regroup
</span></a><span>    </span><a href = "#H_3FEF8C3B"><span>poly2mesh
</span></a><span>    </span><a href = "#H_8E842F63"><span>poly2meshBuiltIn
</span></a><span>    </span><a href = "#H_A5CAB11D"><span>getNodeEle
</span></a><span>    </span><a href = "#H_DB821AD1"><span>printInp_multiPart
</span></a><span>    </span><a href = "#H_6B129422"><span>printInp_multiSect
</span></a><span>    </span><a href = "#H_D87B9871"><span>printBdf
</span></a><span>    </span><a href = "#H_44329623"><span>printTria
</span></a><span>    </span><a href = "#H_0B6DA5FA"><span>getPixelPercent
</span></a><span>    </span><a href = "#H_B90E472F"><span>getPolyShapePercent
</span></a><span>    </span><a href = "#H_A0E484E4"><span>bound2polyshape
</span></a><a href = "#H_3FB0A2D5"><span>Parameters
</span></a><span>    </span><a href = "#H_43A2964E"><span>Parameters and their default values of function im2mesh
</span></a><span>    </span><a href = "#H_F2B77118"><span>Parameters and their default values of function im2meshBuiltIn
</span></a><span>    </span><a href = "#H_BFC7A027"><span>tf_avoid_sharp_corner
</span></a><span>    </span><a href = "#H_40C53CF7"><span>lambda
</span></a><span>    </span><a href = "#H_E421C7CB"><span>mu
</span></a><span>    </span><a href = "#H_B393A452"><span>iters
</span></a><span>    </span><a href = "#H_081F5229"><span>threshold_num_turning
</span></a><span>    </span><a href = "#H_9BCF58B2"><span>threshold_num_vert_Smo
</span></a><span>    </span><a href = "#H_8568A9E8"><span>tolerance
</span></a><span>    </span><a href = "#H_7F2768D6"><span>threshold_num_vert_Sim
</span></a><span>    </span><a href = "#H_BA17B668"><span>grad_limit
</span></a><span>    </span><a href = "#H_0A2970A0"><span>hmax
</span></a><span>    </span><a href = "#H_C7DD010F"><span>mesh_kind
</span></a><span>    </span><a href = "#H_07E6DC18"><span>select_phase
</span></a><span>    </span><a href = "#H_01B2085C"><span>hgrad
</span></a><span>    </span><a href = "#H_A2C31C38"><span>hmin</span></a></div></div><h2  class = 'S5' id = 'H_799D755F' ><span></span></h2><h2  class = 'S6' id = 'H_B8071DE5' ><span>Functions</span></h2><div  class = 'S1'><span>Functions are sorted according to the workflow of Im2mesh package.</span></div><h4  class = 'S7' id = 'H_D96BEA78' ><span>im2mesh</span></h4><div  class = 'S1'><span>Generate triangular mesh based on grayscale segmented image using MESH2D mesh generator (Darren Engwirda)</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre"><span >[ vert, tria, tnum ] = im2mesh( im );   </span><span style="color: rgb(2, 128, 9);">% this use default opt setting</span></span></div></div><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >[ vert, tria, tnum ] = im2mesh( im, opt );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_3543A41B' ><span>im2meshBuiltIn</span></h4><div  class = 'S1'><span>Generate triangular mesh based on grayscale segmented image using matlab built-in function generateMesh</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre"><span >[ vert, tria, tnum ] = im2meshBuiltIn( im );   </span><span style="color: rgb(2, 128, 9);">% this use default setting</span></span></div></div><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >[ vert, tria, tnum ] = im2meshBuiltIn( im, opt );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_E00C71E9' ><span style=' font-weight: bold;'>plotMeshes</span></h4><div  class = 'S1'><span>Plot meshes</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >plotMeshes( vert, tria, tnum );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_97F00184' ><span>tricost</span></h4><div  class = 'S1'><span>Evaluate mesh quality</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >tricost(vert,tria,tnum);</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_43CC0292' ><span>im2Bounds</span></h4><div  class = 'S1'><span>Extract exact polygonal boundaries from grayscale segmented image using getExactBounds.m</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >bounds = im2Bounds( im );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_22838695' ><span>getExactBounds</span></h4><div  class = 'S1'><span>Get the exact boundaries (polygonal) of binary image</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >Bs = getExactBounds( bw );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_38D85220' ><span>totalNumVertex</span></h4><div  class = 'S1'><span>Calculate the total number of vertices in all polygonal boundaries</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >num_vert = totalNumVertex( bounds );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_8514C0F0' ><span>getCtrlPnts</span></h4><div  class = 'S1'><span>Get control points in polygon boundaries</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >new_bounds = getCtrlPnts( bounds, tf_avoid_sharp_corner, size_im );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_30E7C1B8' ><span>plotBounds</span></h4><div  class = 'S1'><span>Plot polygon boundaries</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre"><span >plotBounds( bounds );</span></span></div></div><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >plotBounds( bounds, true );     </span><span style="color: rgb(2, 128, 9);">% show starting and control points</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_FCA5055E' ><span>totalNumCtrlPnt</span></h4><div  class = 'S1'><span>Calculate the total number of control points in all polygonal boundaries. Each polygon has at least one ccontrol point (i.e., the starting vertex).</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >num_ctrlp = totalNumCtrlPnt( bounds );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_10050E27' ><span>smoothBounds</span></h4><div  class = 'S1'><span>Smooth polygon boundaries using 2d Taubin Smoothing (taubinSmooth.m)</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre"><span >new_bounds = smoothBounds( bounds, lambda, mu, iters, </span><span style="color: rgb(14, 0, 255);">...</span></span></div></div><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >                            threshold_num_turning, threshold_num_vert );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_4587B208' ><span style=' font-weight: bold;'>smoothBoundsCCMA</span></h4><div  class = 'S1'><span>Smooth polygon boundaries using CCMA smoothing algorithm (CCMA.m)</span></div><div  class = 'S1'><span>CCMA stand for curvature corrected moving average (https://github.com/UniBwTAS/ccma).</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre"><span >new_bounds = smoothBoundsCCMA( bounds, w_ma, w_cc, </span><span style="color: rgb(14, 0, 255);">...</span></span></div></div><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >                            threshold_num_turning, threshold_num_vert );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_91DFF793' ><span style=' font-weight: bold;'>simplifyBounds</span></h4><div  class = 'S1'><span>Simplify polygon boundaries using Douglas–Peucker algorithm (dpsimplify.m)</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >new_bounds = simplifyBounds( bounds, tolerance, threshold_num_vert )</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_2CF1EA9E' ><span>delZeroAreaPoly</span></h4><div  class = 'S1'><span>Delete polygon with zero area</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >bounds = delZeroAreaPoly( bounds );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_3BBB7560' ><span>getPolyNodeEdge</span></h4><div  class = 'S1'><span>Get nodes and edges of polygonal boundary</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >[ poly_node, poly_edge ] = getPolyNodeEdge( bounds );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_FCED5924' ><span>regroup</span></h4><div  class = 'S1'><span>Organize cell array poly_node, poly_edge into array nodeU, edgeU &amp; cell array part for MESH2D</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >[ nodeU, edgeU, part ] = regroup( poly_node, poly_edge );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_3FEF8C3B' ><span>poly2mesh</span></h4><div  class = 'S1'><span>Generate meshes of parts defined by polygons using MESH2D mesh generator (Darren Engwirda)</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >[vert,tria,tnum] = poly2mesh( poly_node, poly_edge, hmax, mesh_kind, grad_limit );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_8E842F63' ><span>poly2meshBuiltIn</span></h4><div  class = 'S1'><span>generate meshes of parts defined by polygons using matlab built-in function generateMesh.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >[ vert, tria, tnum ] = im2meshBuiltIn( im, opt );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_A5CAB11D' ><span style=' font-weight: bold;'>getNodeEle</span></h4><div  class = 'S1'><span>Get node coordinares and elements from mesh</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >[ nodecoor_list, nodecoor_cell, ele_cell ] = getNodeEle( vert, tria, tnum, ele_order );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_DB821AD1' ><span>printInp_multiPart</span></h4><div  class = 'S1'><span>Print the nodes and elements into Inp file 'test_multi_parts.inp', test in software Abaqus. Each phase corresponds to one part in Abaqus.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >printInp_multiPart( nodecoor_cell, ele_cell, ele_type, precision_nodecoor );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_6B129422' ><span>printInp_multiSect</span></h4><div  class = 'S1'><span>Print the nodes and elements into Inp file 'test_multi_sections.inp', test in software Abaqus. One part with multiple sections. Each phase corresponds to one section in Abaqus.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >printInp_multiSect( nodecoor_list, ele_cell, ele_type, precision_nodecoor );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_D87B9871' ><span>printBdf</span></h4><div  class = 'S1'><span>Print the nodes and elements into Inp file 'test.bdf'</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >printBdf( nodecoor_list, ele_cell, precision_nodecoor );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_44329623' ><span>printTria</span></h4><div  class = 'S1'><span>Print nodes and elements into file 'test.node' &amp; 'test.ele'. Only support triangular element with 3 nodes. Precision is number of digits behind decimal point, for node coordinates</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >printTria( vert, tria, tnum, precision_nodecoor );  </span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_0B6DA5FA' ><span style=' font-weight: bold;'>getPixelPercent</span></h4><div  class = 'S1'><span>calculate the area perccentage of each grayscale in image</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >percent_pixel = getPixelPercent( im );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_B90E472F' ><span style=' font-weight: bold;'>getPolyShapePercent</span></h4><div  class = 'S1'><span>calculate the area perccentage of each phase in polygonal boundaries</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >percent_polyarea = getPolyShapePercent( bounds );</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_A0E484E4' ><span>bound2polyshape</span></h4><div  class = 'S1'><span>Convert polygonal boundaries to a cell array of polyshape object</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre"><span >p = bound2polyshape( bounds );</span></span></div></div></div><div  class = 'S10'><span></span></div><div  class = 'S1'><span></span></div><h2  class = 'S6' id = 'H_3FB0A2D5' ><span>Parameters</span></h2><h4  class = 'S7' id = 'H_43A2964E' ><span style=' font-weight: bold;'>Parameters and their default values of function im2mesh</span></h4><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre"><span >opt.tf_avoid_sharp_corner = false;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.lambda = 0.7;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.mu = -0.4;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.iters = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.threshold_num_turning = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.threshold_num_vert_Smo = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.tolerance = 0.3;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.threshold_num_vert_Sim = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.grad_limit = 0.25;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.hmax = 500;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.mesh_kind = </span><span style="color: rgb(170, 4, 249);">'delaunay'</span><span >;</span></span></div></div><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >opt.select_phase = [];</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_F2B77118' ><span style=' font-weight: bold;'>Parameters and their default values of function im2meshBuiltIn</span></h4><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre"><span >opt.tf_avoid_sharp_corner = false;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.lambda = 0.7;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.mu = -0.4;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.iters = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.threshold_num_turning = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.threshold_num_vert_Smo = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.tolerance = 0.3;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.threshold_num_vert_Sim = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.hgrad = 1.25;</span></span></div></div><div class="inlineWrapper"><div  class = 'S12'><span style="white-space: pre"><span >opt.hmax = 500;</span></span></div></div><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >opt.hmin = 1;</span></span></div></div></div><div  class = 'S10'><span></span></div><h4  class = 'S7' id = 'H_BFC7A027' ><span style=' font-weight: bold;'>tf_avoid_sharp_corner</span></h4><div  class = 'S1'><span>Type: boolean. </span></div><div  class = 'S1'><span>For getCtrlPnts.</span></div><div  class = 'S1'><span>Meaning: Whether to avoid sharp corner when simplifying polygon. If true, two extra control points will be added around one original control point to avoid sharp corner when simplifying polygon.</span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_40C53CF7' ><span style=' font-weight: bold;'>lambda</span></h4><div  class = 'S1'><span>Type: Float. Range: 0 &lt; Lambda &lt; 1.</span></div><div  class = 'S1'><span>For smoothBounds.</span></div><div  class = 'S1'><span>Meaning: How far each node is moved toward the average position of its neighbours during every second iteration.</span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_E421C7CB' ><span style=' font-weight: bold;'>mu</span></h4><div  class = 'S1'><span>Type: Float. Range: -1&lt; Mu &lt; 0.</span></div><div  class = 'S1'><span>For smoothBounds.</span></div><div  class = 'S1'><span>Meaning: How far each node is moved opposite the direction of the average position of its neighbours during every second iteration. </span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_B393A452' ><span style=' font-weight: bold;'>iters</span></h4><div  class = 'S1'><span>Type: Integer. Range: ≥ 0.</span></div><div  class = 'S1'><span>For smoothBounds.</span></div><div  class = 'S1'><span>Meaning: Number of iterations in Taubin smoothing. If you don’t need polyline smoothing, set Iterations to 0. </span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_081F5229' ><span style=' font-weight: bold;'>threshold_num_turning</span></h4><div  class = 'S1'><span>Type: Integer. Range: ≥ 0.</span></div><div  class = 'S1'><span>For smoothBounds.</span></div><div  class = 'S1'><span>Meaning: Threshold value for the number of turning points in a polyline. Only those polylines with number of turning points greater than this threshold will be smoothed. </span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_9BCF58B2' ><span style=' font-weight: bold;'>threshold_num_vert_Smo</span></h4><div  class = 'S1'><span>Type: Integer. Range: ≥ 0.</span></div><div  class = 'S1'><span>For smoothBounds.</span></div><div  class = 'S1'><span>Meaning: Threshold value for the number of vertices in a polyline. Only those polylines with number of vertices greater than this threshold will be smoothed.</span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_8568A9E8' ><span style=' font-weight: bold;'>tolerance</span></h4><div  class = 'S1'><span>Type: Float. Range: ≥ 0.</span></div><div  class = 'S1'><span>For simplifyBounds.</span></div><div  class = 'S1'><span>Meaning: The maximum allowable deviation of a vertex from the simplified curve. It’s for Douglas-Peucker algorithm. If you don’t need to simplify polylines, set tolerance to 0.</span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_7F2768D6' ><span style=' font-weight: bold;'>threshold_num_vert_Sim</span></h4><div  class = 'S1'><span>Type: Integer. Range: ≥ 0.</span></div><div  class = 'S1'><span>For simplifyBounds.</span></div><div  class = 'S1'><span>Meaning: Threshold value for the number of vertices in a polyline. Only those polylines with number of vertices greater than this threshold will be simplified. </span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_BA17B668' ><span style=' font-weight: bold;'>grad_limit</span></h4><div  class = 'S1'><span>Type: Float. Range: &gt; 0. Typical value: 0.2 - 0.5.</span></div><div  class = 'S1'><span>For poly2mesh &amp; MESH2D.</span></div><div  class = 'S1'><span>Meaning: Gradient-limit, a limit on the gradient of mesh-size function.</span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_0A2970A0' ><span style=' font-weight: bold;'>hmax</span></h4><div  class = 'S1'><span>Type: Float. Range: &gt; 0.</span></div><div  class = 'S1'><span>For poly2mesh &amp; MESH2D.</span></div><div  class = 'S1'><span>Meaning: Maximum mesh edge lengths. This is an approximate upper bound on the mesh edge lengths.</span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_C7DD010F' ><span style=' font-weight: bold;'>mesh_kind</span></h4><div  class = 'S1'><span>Value: 'delaunay' or 'delfront'</span></div><div  class = 'S1'><span>For poly2mesh &amp; MESH2D.</span></div><div  class = 'S1'><span>Meaning: Meshing algorithm used to create mesh-size functions based on an estimate of the "local-feature-size" associated with a polygonal domain. 'delaunay' means Delaunay-refinement. 'delfront' means Frontal-Delaunay.</span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_07E6DC18' ><span style=' font-weight: bold;'>select_phase</span></h4><div  class = 'S1'><span>Type: vector</span></div><div  class = 'S1'><span>Meaning: Select certain phases in image for meshing. If 'select_phase' is [], all the phases will be chosen.</span></div><div  class = 'S1'><span>'select_phase' is an index vector for sorted grayscales (ascending order) in an image. For example, an image with grayscales of 40, 90, 200, 240, 255. If u're interested in 40, 200, and 240, then set 'select_phase' as [1 3 4]. Those phases corresponding to grayscales of 40, 200, and 240 will be chosen to perform meshing.</span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_01B2085C' ><span style=' font-weight: bold;'>hgrad</span></h4><div  class = 'S1'><span>Type: Float. Range: 1 ≤ Mesh Growth Rate ≤ 2. Typical value: 1.2 - 1.5.</span></div><div  class = 'S1'><span>For poly2meshBuiltIn &amp; generateMesh</span></div><div  class = 'S1'><span>Meaning: Mesh growth rate, the rate at which the mesh transitions between regions of different edge size. </span></div><div  class = 'S1'><span></span></div><h4  class = 'S7' id = 'H_A2C31C38' ><span style=' font-weight: bold;'>hmin</span></h4><div  class = 'S1'><span>Type: Float. Range: ≥ 0.</span></div><div  class = 'S1'><span>For poly2meshBuiltIn &amp; generateMesh</span></div><div  class = 'S1'><span>Meaning: Min mesh edge length, an approximate lower bound on the mesh edge lengths.</span></div><div  class = 'S1'><span></span></div><div  class = 'S1'><span></span></div><div  class = 'S1'><span></span></div><div  class = 'S1'><span></span></div><div  class = 'S1'></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% Im2mesh Function List and Parameters
% 
%% 
%% Functions
% Functions are sorted according to the workflow of Im2mesh package.
% im2mesh
% Generate triangular mesh based on grayscale segmented image using MESH2D mesh 
% generator (Darren Engwirda)

[ vert, tria, tnum ] = im2mesh( im );   % this use default opt setting
[ vert, tria, tnum ] = im2mesh( im, opt );
%% 
% 
% im2meshBuiltIn
% Generate triangular mesh based on grayscale segmented image using matlab built-in 
% function generateMesh

[ vert, tria, tnum ] = im2meshBuiltIn( im );   % this use default setting
[ vert, tria, tnum ] = im2meshBuiltIn( im, opt );
%% 
% 
% *plotMeshes*
% Plot meshes

plotMeshes( vert, tria, tnum );
%% 
% 
% tricost
% Evaluate mesh quality

tricost(vert,tria,tnum);
%% 
% 
% im2Bounds
% Extract exact polygonal boundaries from grayscale segmented image using getExactBounds.m

bounds = im2Bounds( im );
%% 
% 
% getExactBounds
% Get the exact boundaries (polygonal) of binary image

Bs = getExactBounds( bw );
%% 
% 
% totalNumVertex
% Calculate the total number of vertices in all polygonal boundaries

num_vert = totalNumVertex( bounds );
%% 
% 
% getCtrlPnts
% Get control points in polygon boundaries

new_bounds = getCtrlPnts( bounds, tf_avoid_sharp_corner, size_im );
%% 
% 
% plotBounds
% Plot polygon boundaries

plotBounds( bounds );
plotBounds( bounds, true );     % show starting and control points
%% 
% 
% totalNumCtrlPnt
% Calculate the total number of control points in all polygonal boundaries. 
% Each polygon has at least one ccontrol point (i.e., the starting vertex).

num_ctrlp = totalNumCtrlPnt( bounds );
%% 
% 
% smoothBounds
% Smooth polygon boundaries using 2d Taubin Smoothing (taubinSmooth.m)

new_bounds = smoothBounds( bounds, lambda, mu, iters, ...
                            threshold_num_turning, threshold_num_vert );
%% 
% 
% *smoothBoundsCCMA*
% Smooth polygon boundaries using CCMA smoothing algorithm (CCMA.m)
% 
% CCMA stand for curvature corrected moving average (https://github.com/UniBwTAS/ccma).

new_bounds = smoothBoundsCCMA( bounds, w_ma, w_cc, ...
                            threshold_num_turning, threshold_num_vert );
%% 
% 
% *simplifyBounds*
% Simplify polygon boundaries using Douglas–Peucker algorithm (dpsimplify.m)

new_bounds = simplifyBounds( bounds, tolerance, threshold_num_vert )
%% 
% 
% delZeroAreaPoly
% Delete polygon with zero area

bounds = delZeroAreaPoly( bounds );
%% 
% 
% getPolyNodeEdge
% Get nodes and edges of polygonal boundary

[ poly_node, poly_edge ] = getPolyNodeEdge( bounds );
%% 
% 
% regroup
% Organize cell array poly_node, poly_edge into array nodeU, edgeU & cell array 
% part for MESH2D

[ nodeU, edgeU, part ] = regroup( poly_node, poly_edge );
%% 
% 
% poly2mesh
% Generate meshes of parts defined by polygons using MESH2D mesh generator (Darren 
% Engwirda)

[vert,tria,tnum] = poly2mesh( poly_node, poly_edge, hmax, mesh_kind, grad_limit );
%% 
% 
% poly2meshBuiltIn
% generate meshes of parts defined by polygons using matlab built-in function 
% generateMesh.

[ vert, tria, tnum ] = im2meshBuiltIn( im, opt );
%% 
% 
% *getNodeEle*
% Get node coordinares and elements from mesh

[ nodecoor_list, nodecoor_cell, ele_cell ] = getNodeEle( vert, tria, tnum, ele_order );
%% 
% 
% printInp_multiPart
% Print the nodes and elements into Inp file 'test_multi_parts.inp', test in 
% software Abaqus. Each phase corresponds to one part in Abaqus.

printInp_multiPart( nodecoor_cell, ele_cell, ele_type, precision_nodecoor );
%% 
% 
% printInp_multiSect
% Print the nodes and elements into Inp file 'test_multi_sections.inp', test 
% in software Abaqus. One part with multiple sections. Each phase corresponds 
% to one section in Abaqus.

printInp_multiSect( nodecoor_list, ele_cell, ele_type, precision_nodecoor );
%% 
% 
% printBdf
% Print the nodes and elements into Inp file 'test.bdf'

printBdf( nodecoor_list, ele_cell, precision_nodecoor );
%% 
% 
% printTria
% Print nodes and elements into file 'test.node' & 'test.ele'. Only support 
% triangular element with 3 nodes. Precision is number of digits behind decimal 
% point, for node coordinates

printTria( vert, tria, tnum, precision_nodecoor );  
%% 
% 
% *getPixelPercent*
% calculate the area perccentage of each grayscale in image

percent_pixel = getPixelPercent( im );
%% 
% 
% *getPolyShapePercent*
% calculate the area perccentage of each phase in polygonal boundaries

percent_polyarea = getPolyShapePercent( bounds );
%% 
% 
% bound2polyshape
% Convert polygonal boundaries to a cell array of polyshape object

p = bound2polyshape( bounds );
%% 
% 
%% 
% 
%% Parameters
% *Parameters and their default values of function im2mesh*

opt.tf_avoid_sharp_corner = false;
opt.lambda = 0.7;
opt.mu = -0.4;
opt.iters = 10;
opt.threshold_num_turning = 10;
opt.threshold_num_vert_Smo = 10;
opt.tolerance = 0.3;
opt.threshold_num_vert_Sim = 10;
opt.grad_limit = 0.25;
opt.hmax = 500;
opt.mesh_kind = 'delaunay';
opt.select_phase = [];
%% 
% 
% *Parameters and their default values of function im2meshBuiltIn*

opt.tf_avoid_sharp_corner = false;
opt.lambda = 0.7;
opt.mu = -0.4;
opt.iters = 10;
opt.threshold_num_turning = 10;
opt.threshold_num_vert_Smo = 10;
opt.tolerance = 0.3;
opt.threshold_num_vert_Sim = 10;
opt.hgrad = 1.25;
opt.hmax = 500;
opt.hmin = 1;
%% 
% 
% *tf_avoid_sharp_corner*
% Type: boolean. 
% 
% For getCtrlPnts.
% 
% Meaning: Whether to avoid sharp corner when simplifying polygon. If true, 
% two extra control points will be added around one original control point to 
% avoid sharp corner when simplifying polygon.
% 
% 
% *lambda*
% Type: Float. Range: 0 < Lambda < 1.
% 
% For smoothBounds.
% 
% Meaning: How far each node is moved toward the average position of its neighbours 
% during every second iteration.
% 
% 
% *mu*
% Type: Float. Range: -1< Mu < 0.
% 
% For smoothBounds.
% 
% Meaning: How far each node is moved opposite the direction of the average 
% position of its neighbours during every second iteration. 
% 
% 
% *iters*
% Type: Integer. Range: ≥ 0.
% 
% For smoothBounds.
% 
% Meaning: Number of iterations in Taubin smoothing. If you don’t need polyline 
% smoothing, set Iterations to 0. 
% 
% 
% *threshold_num_turning*
% Type: Integer. Range: ≥ 0.
% 
% For smoothBounds.
% 
% Meaning: Threshold value for the number of turning points in a polyline. Only 
% those polylines with number of turning points greater than this threshold will 
% be smoothed. 
% 
% 
% *threshold_num_vert_Smo*
% Type: Integer. Range: ≥ 0.
% 
% For smoothBounds.
% 
% Meaning: Threshold value for the number of vertices in a polyline. Only those 
% polylines with number of vertices greater than this threshold will be smoothed.
% 
% 
% *tolerance*
% Type: Float. Range: ≥ 0.
% 
% For simplifyBounds.
% 
% Meaning: The maximum allowable deviation of a vertex from the simplified curve. 
% It’s for Douglas-Peucker algorithm. If you don’t need to simplify polylines, 
% set tolerance to 0.
% 
% 
% *threshold_num_vert_Sim*
% Type: Integer. Range: ≥ 0.
% 
% For simplifyBounds.
% 
% Meaning: Threshold value for the number of vertices in a polyline. Only those 
% polylines with number of vertices greater than this threshold will be simplified. 
% 
% 
% *grad_limit*
% Type: Float. Range: > 0. Typical value: 0.2 - 0.5.
% 
% For poly2mesh & MESH2D.
% 
% Meaning: Gradient-limit, a limit on the gradient of mesh-size function.
% 
% 
% *hmax*
% Type: Float. Range: > 0.
% 
% For poly2mesh & MESH2D.
% 
% Meaning: Maximum mesh edge lengths. This is an approximate upper bound on 
% the mesh edge lengths.
% 
% 
% *mesh_kind*
% Value: 'delaunay' or 'delfront'
% 
% For poly2mesh & MESH2D.
% 
% Meaning: Meshing algorithm used to create mesh-size functions based on an 
% estimate of the "local-feature-size" associated with a polygonal domain. 'delaunay' 
% means Delaunay-refinement. 'delfront' means Frontal-Delaunay.
% 
% 
% *select_phase*
% Type: vector
% 
% Meaning: Select certain phases in image for meshing. If 'select_phase' is 
% [], all the phases will be chosen.
% 
% 'select_phase' is an index vector for sorted grayscales (ascending order) 
% in an image. For example, an image with grayscales of 40, 90, 200, 240, 255. 
% If u're interested in 40, 200, and 240, then set 'select_phase' as [1 3 4]. 
% Those phases corresponding to grayscales of 40, 200, and 240 will be chosen 
% to perform meshing.
% 
% 
% *hgrad*
% Type: Float. Range: 1 ≤ Mesh Growth Rate ≤ 2. Typical value: 1.2 - 1.5.
% 
% For poly2meshBuiltIn & generateMesh
% 
% Meaning: Mesh growth rate, the rate at which the mesh transitions between 
% regions of different edge size. 
% 
% 
% *hmin*
% Type: Float. Range: ≥ 0.
% 
% For poly2meshBuiltIn & generateMesh
% 
% Meaning: Min mesh edge length, an approximate lower bound on the mesh edge 
% lengths.
% 
% 
% 
% 
% 
% 
% 
% 
% 
%
##### SOURCE END #####
-->
</div></body></html>